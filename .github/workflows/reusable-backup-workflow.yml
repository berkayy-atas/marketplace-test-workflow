#.github/workflows/reusable-backup-workflow.yml
name: Reusable Backup Workflow with Cache

# Bu iş akışının başka iş akışları tarafından çağrılabilmesini sağlar.
on:
  workflow_call:
    inputs:
      backup-file-name:
        description: 'Name for the backup archive file.'
        required: true
        type: string
      source-path:
        description: 'Path to the directory or file to back up.'
        required: true
        type: string
        default: '.'
      upload-target-url:
        description: 'Optional URL for uploading the backup to an off-site location.'
        required: false
        type: string
    secrets:
      OFFSITE_UPLOAD_TOKEN:
        description: 'Token for uploading the backup to an off-site location.'
        required: true

# İş akışı düzeyinde bir ortam değişkeni olarak benzersiz önbellek anahtarını tanımlar.
# Bu, tüm işlerde tutarlı bir anahtar kullanılmasını sağlar.
env:
  BACKUP_CACHE_KEY: backup-cache-${{ github.run_id }}

jobs:
  # İŞ 1: Yedek dosyasını oluşturur ve doğrudan önbelleğe kaydeder.
  create_and_cache_backup:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Depo içeriğini okumak için gereklidir.
    steps:
      # Adım 1.1: Depoyu klonla. fetch-depth: 0, tam bir yedekleme için tüm geçmişi alır.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Adım 1.2: Hızlı sıkıştırma için zstd aracını yükle.
      - name: Install zstd for high-speed compression
        run: sudo apt-get update && sudo apt-get install -y zstd

      # Adım 1.3: Yedek arşivini oluştur.
      # tar, en iyi hız ve sıkıştırma oranı için zstd ile kullanılır.
      # -T0 parametresi, mevcut tüm işlemci çekirdeklerini kullanmasını sağlar.
      - name: Create backup archive
        run: |
          tar --use-compress-program="zstd -T0" -cf ${{ inputs.backup-file-name }} ${{ inputs.source-path }}
          echo "Backup file created: ${{ inputs.backup-file-name }}"
          ls -lh ${{ inputs.backup-file-name }}

      # Adım 1.4: Yedeklemeyi önbelleğe kaydet.
      # actions/cache eylemi, işin sonunda (post-job) belirtilen yolu otomatik olarak kaydeder.
      # restore-keys KULLANILMAZ, çünkü eski bir yedeği geri yüklemek istemiyoruz.
      - name: Save backup to cache
        uses: actions/cache@v4
        with:
          path: ${{ inputs.backup-file-name }}
          key: ${{ env.BACKUP_CACHE_KEY }}

  # İŞ 2: Yedeklemeyi önbellekten geri yükler ve işler (doğrulama, yükleme vb.).
  restore_and_process_backup:
    runs-on: ubuntu-latest
    # Bu işin başlaması için create_and_cache_backup işinin tamamlanması gerekir.
    needs: create_and_cache_backup
    permissions:
      contents: read # Harici yükleme betiklerinin çalışması için gerekebilir.
    steps:
      # Adım 2.1: Yedeklemeyi önbellekten geri yükle.
      # actions/cache/restore@v4, yalnızca geri yükleme yapmak için daha açık bir eylemdir.
      - name: Restore backup from cache
        id: cache_restore
        uses: actions/cache/restore@v4
        with:
          path: ${{ inputs.backup-file-name }}
          key: ${{ env.BACKUP_CACHE_KEY }}
          # fail-on-cache-miss: true, bu mimarinin güvenilirliği için kritiktir.
          # Önbellek bulunamazsa (yani, önceki iş başarısız olduysa), bu iş de başarısız olur.
          # Bu, sessiz hataları önler.[24, 25]
          fail-on-cache-miss: true

      # Adım 2.2: Yedekleme bütünlüğünü doğrula (örnek adım).
      - name: Verify backup integrity
        run: |
          echo "Verifying backup file..."
          file ${{ inputs.backup-file-name }}
          ls -lh ${{ inputs.backup-file-name }}
          # Gerçek bir senaryoda burada md5/sha256 kontrolü yapılabilir.

      # Adım 2.3: Harici Depolama Alanına Yükle (örnek adım).
      # Bu adım yalnızca upload-target-url girdisi sağlandıysa çalışır.
      - name: Upload to Off-site Storage
        if: ${{ inputs.upload-target-url!= '' }}
        env:
          UPLOAD_TOKEN: ${{ secrets.OFFSITE_UPLOAD_TOKEN }}
        run: |
          echo "Uploading ${{ inputs.backup-file-name }} to ${{ inputs.upload-target-url }}..."
          # Gerçek yükleme komut dosyası buraya eklenir (örn. curl, aws s3 cp, vs.).
          echo "Upload complete."

  # İŞ 3: Başarılı bir çalıştırmanın ardından önbellek girişini temizler.
  cleanup_backup_cache:
    runs-on: ubuntu-latest
    # Bu iş, yalnızca restore_and_process_backup işi başarılı olursa çalışır.
    needs: restore_and_process_backup
    # if: success() koşulu, önceki işin sonucunun 'success' olmasını gerektirir.
    if: success()
    permissions:
      # gh cache delete komutunun çalışması için 'actions: write' izni gereklidir.
      actions: write
      contents: read
    steps:
      - name: Delete backup cache entry
        env:
          # GitHub CLI'nin kimlik doğrulaması için GITHUB_TOKEN gereklidir.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Cleaning up cache with key: ${{ env.BACKUP_CACHE_KEY }}"
          gh cache delete "${{ env.BACKUP_CACHE_KEY }}" --confirm
