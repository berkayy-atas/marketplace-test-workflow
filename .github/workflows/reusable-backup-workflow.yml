#.github/workflows/reusable-backup-workflow.yml

name: Reusable Backup Workflow with Cache

on:
  workflow_call:
    secrets:
      activation_code:
        description: 'Activation code for the backup service'
        required: true
      encryption_password:
        description: 'Password to encrypt the backup archive'
        required: true
        
# Her iş akışı çalıştırması için benzersiz bir önbellek anahtarı tanımlıyoruz.
env:
  BACKUP_CACHE_KEY: backup-cache-${{ github.run_id }}

jobs:

  inputs_check:
    runs-on: ubuntu-latest
    steps:
      - name: Validate encryption password length
        shell: bash
        run: |
          ENC_KEY="${{ secrets.encryption_password }}"
          if [ "${#ENC_KEY}" -lt 32 ]; then
            echo "::error ::The encryption_password must be at least 32 characters long (got ${#ENC_KEY})."
            exit 1
          fi
          
  uploading_and_encryption:
    runs-on: ubuntu-latest
    needs: inputs_check
    outputs:
      encrypted_file_name: ${{ steps.encrypt_step.outputs.encrypted_file_name }}
      uncompressed_size: ${{ steps.encrypt_step.outputs.uncompressed }}
      compressed_size: ${{ steps.encrypt_step.outputs.compressed }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
  
      - name: Configure Repository for Full Mirror
        shell: bash
        run: |
          git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
          git config remote.origin.tagopt --tags
          git fetch origin --prune --tags --force
          
          git for-each-ref --format='%(refname:short)' refs/remotes/origin | grep -v HEAD | while read branch; do
              b=${branch#origin/}
              if ! git show-ref --quiet refs/heads/"$b"; then
                  git branch "$b" "$branch"
              fi
          done

      - name: Clone Repository in Mirror Mode
        shell: bash
        run: |
          git clone --mirror . repo-mirror
          cd repo-mirror
          echo "--- Mirror Branches ---"
          git branch -a
          echo "--- Mirror Tags ---"
          git tag -l
  
      - name: Install Dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y zstd jq
  
          
      - name: Encrypt Compressed Repository
        id: encrypt_step
        shell: bash
        run: |
          REPO_NAME=$(basename "${{ github.repository }}")
          ENC_FILE_NAME="$REPO_NAME.tar.zst.enc"

          tar -cf repo.tar repo-mirror
          zstd -9 repo.tar -o repo.tar.zst
          openssl enc -aes-256-cbc -salt -pbkdf2 -in repo.tar.zst -out "$ENC_FILE_NAME" -pass pass:${{ secrets.encryption_password }}

          echo "ENC_FILE_NAME=$ENC_FILE_NAME" >> $GITHUB_ENV

          echo "encrypted_file_name=$ENC_FILE_NAME" >> $GITHUB_OUTPUT
          echo "uncompressed=$(stat --printf='%s' repo.tar)" >> $GITHUB_OUTPUT
          echo "compressed=$(stat --printf='%s' "$ENC_FILE_NAME")" >> $GITHUB_OUTPUT

      - name: Update CLI and Save Cache with Retry
        shell: bash
        env:
          # gh CLI'nin kimlik doğrulaması için GITHUB_TOKEN gereklidir.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. GitHub CLI'ı en son versiyona güncelle
          echo "Updating GitHub CLI..."
          type -p curl >/dev/null || (sudo apt-get update && sudo apt-get install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt-get update \
          && sudo apt-get install gh -y
          echo "Installed gh version:"
          gh --version
          echo "---------------------------------"

          # 2. Güncellenmiş CLI ile önbelleği kaydetmeyi dene
          for i in 1 2; do
            echo "Attempting to save cache (Attempt $i)..."
            
            # gh cache upload komutu ile dosyayı önbelleğe yüklemeyi deniyoruz.
            if gh cache upload "${{ env.ENC_FILE_NAME }}" --key "${{ env.BACKUP_CACHE_KEY }}"; then
              echo "✅ Cache saved successfully on attempt $i."
              exit 0
            fi

            # Eğer bu son deneme ise (i=2), hata ile çık.
            if [ $i -eq 2 ]; then
              echo "::error::Cache save failed after 2 attempts. Aborting workflow."
              exit 1
            fi
            
            # Son deneme değilse, bir uyarı ver ve tekrar denemeden önce 5 saniye bekle.
            echo "::warning::Cache save failed on attempt $i. Retrying in 5 seconds..."
            sleep 5
          done
          
  # 2. İş: Önbellekten Geri Yükle ve Depolamaya Yükle
  auth_and_Upload:
    runs-on: ubuntu-latest
    needs: uploading_and_encryption
    steps:
      # Artifact yerine, şifrelenmiş dosyayı önbellekten geri yüklüyoruz.
      - name: Restore encrypted backup from cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ needs.uploading_and_encryption.outputs.encrypted_file_name }}
          key: ${{ env.BACKUP_CACHE_KEY }}
          # Bu parametre kritik öneme sahiptir: Önbellek bulunamazsa, iş başarısız olur.
          fail-on-cache-miss: true
      
      - name: Get Activation Token
        id: activation
        shell: bash
        run: |
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://dev.api.file-security.icredible.com/endpoint/activation" \
          -H "Content-Type: application/json" \
          -d '{
            "activationCode": "${{ secrets.activation_code }}",
            "uniqueId": "${{ github.repository_id }}",
            "ip": "${{ runner.ip }}",
            "operatingSystem": "Linux",
            "endpointType": "Workstation",
            "endpointName": "Github Endpoint (${{ github.repository }})"
          }')
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          JSON_BODY=$(echo "$RESPONSE" | head -n -1)
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Activation failed: $JSON_BODY"
            exit 1
          fi

          echo "token=$(echo "$JSON_BODY" | jq -r '.data.token')" >> $GITHUB_OUTPUT
          echo "endpointId=$(echo "$JSON_BODY" | jq -r '.data.endpointId')" >> $GITHUB_OUTPUT
  
      - name: Upload Backup to Shield API (with dynamic commit meta)
        id: shieldRequest
        shell: bash
        env:
          TOKEN: ${{ steps.activation.outputs.token }}
        run: |
          ENC_FILE_NAME="${{ needs.uploading_and_encryption.outputs.encrypted_file_name }}"
          UNCOMPRESSED_SIZE="${{ needs.uploading_and_encryption.outputs.uncompressed_size }}"
          COMPRESSED_SIZE="${{ needs.uploading_and_encryption.outputs.compressed_size }}"

          EVENT="${{ github.event_name }}"
          REF="${{ github.ref }}"
          ACTOR="${{ github.actor }}"
          OWNER="${{ github.repository_owner }}"
          OWNER_TYPE="${{ github.event.repository.owner.type }}"
          
          if git rev-parse --verify HEAD >/dev/null 2>&1; then
            COMMIT=$(git log -1 --pretty=format:"%H")
            SHORT=$(git log -1 --pretty=format:"%h")
            PARENTS=$(git log -1 --pretty=format:"%P")
            AUTHOR=$(git log -1 --pretty=format:"%an <%ae>")
            DATE=$(git log -1 --pretty=format:"%ad")
            COMMITTER=$(git log -1 --pretty=format:"%cn")
            MESSAGE=$(git log -1 --pretty=format:"%s%n%b")
          else
            COMMIT=""
            SHORT=""
            PARENTS=""
            AUTHOR=""
            DATE=""
            COMMITTER=""
            MESSAGE=""
          fi
          
          CURL_ARGS=(
            -F "MetaData[Event]=$EVENT"
            -F "MetaData[Ref]=$REF"
            -F "MetaData[Actor]=$ACTOR"
            -F "MetaData[Owner]=$OWNER"
            -F "MetaData[OwnerType]=$OWNER_TYPE"
          )
          [ -n "$COMMIT" ] && CURL_ARGS+=(-F "MetaData[Commit]=$COMMIT")
          [ -n "$SHORT" ] && CURL_ARGS+=(-F "MetaData[CommitShort]=$SHORT")
          [ -n "$PARENTS" ] && CURL_ARGS+=(-F "MetaData[Parents]=$PARENTS")
          [ -n "$AUTHOR" ] && CURL_ARGS+=(-F "MetaData[Author]=$AUTHOR")
          [ -n "$DATE" ] && CURL_ARGS+=(-F "MetaData[Date]=$DATE")
          [ -n "$COMMITTER" ] && CURL_ARGS+=(-F "MetaData[Committer]=$COMMITTER")
          [ -n "$MESSAGE" ] && CURL_ARGS+=(-F "MetaData[Message]=$MESSAGE")

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://dev.api.file-security.icredible.com/backup/shield" \
            -H "Authorization: Bearer $TOKEN" \
            -F "file=@$ENC_FILE_NAME" \
            -F "Size=$UNCOMPRESSED_SIZE" \
            -F "CompressedFileSize=$COMPRESSED_SIZE" \
            -F "Attributes=32" \
            -F "FileName=${{ github.repository }}" \
            -F "CompressionEngine=None" \
            -F "CompressionLevel=NoCompression" \
            -F "FullPath=/${{ github.repository }}/repo.tar.zst" \
            -F "encryptionType=None" \
            -F "RevisionType=1" \
            "${CURL_ARGS[@]}"
          )

          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          JSON_BODY=$(echo "$RESPONSE" | head -n -1)
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Upload failed: $JSON_BODY"
            exit 1
          fi

          echo "recordId=$(echo "$JSON_BODY" | jq -r '.data.recordId')" >> $GITHUB_ENV
          echo "directoryRecordId=$(echo "$JSON_BODY" | jq -r '.data.directoryRecordId')" >> $GITHUB_ENV
          
          # Özet adımı için tüm git verilerini çıktı olarak ayarlıyoruz.
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "commitShort=$SHORT" >> $GITHUB_OUTPUT
          echo "parents=$PARENTS" >> $GITHUB_OUTPUT
          echo "author=$AUTHOR" >> $GITHUB_OUTPUT
          echo "date=$DATE" >> $GITHUB_OUTPUT
          echo "committer=$COMMITTER" >> $GITHUB_OUTPUT
          echo "message=$(echo "$MESSAGE" | tr '\n' ' ')" >> $GITHUB_OUTPUT

          echo "Backup uploaded successfully."

      # YENİ ADIM: Yedekleme özetini loglara yazdırır.
      - name: Print Backup Summary
        if: success()
        shell: bash
        env:
          # Önceki adımlardan gelen çıktıları bu adımın ortam değişkenlerine atıyoruz.
          recordId: ${{ steps.shieldRequest.outputs.recordId }}
          directoryRecordId: ${{ steps.shieldRequest.outputs.directoryRecordId }}
          commit: ${{ steps.shieldRequest.outputs.commit }}
          commitShort: ${{ steps.shieldRequest.outputs.commitShort }}
          parents: ${{ steps.shieldRequest.outputs.parents }}
          author: ${{ steps.shieldRequest.outputs.author }}
          date: ${{ steps.shieldRequest.outputs.date }}
          committer: ${{ steps.shieldRequest.outputs.committer }}
          message: ${{ steps.shieldRequest.outputs.message }}
          endpointId: ${{ steps.activation.outputs.endpointId }}
        run: |
          # Tüm mesajı, yeni satır karakterleri ($'\n') kullanarak tek bir değişkende biriktiriyoruz.
          MESSAGE="✅ **Backup completed successfully!**"
          MESSAGE+=$'\n\n'
          MESSAGE+="--------------------------------------------------\n"
          MESSAGE+="**Git Metadata**\n"
          MESSAGE+="Repository: ${{ github.repository }}\n"
          MESSAGE+="- Owner: ${{ github.repository_owner }} [${{ github.event.repository.owner.type }}]\n"
          MESSAGE+="- Event: ${{ github.event_name }}\n"
          MESSAGE+="- Ref:   ${{ github.ref }}\n"
          MESSAGE+="- Actor: ${{ github.actor }}\n"

          # Eğer commit bilgisi varsa, ilgili bölümü mesaja ekliyoruz.
          if [ -n "${{ env.commit }}" ]; then
            MESSAGE+=$'\n'
            MESSAGE+="--------------------------------------------------\n"
            MESSAGE+="**Upload Metadata**\n"
            MESSAGE+="- Commit:      ${{ env.commit }}\n"
            MESSAGE+="- CommitShort: ${{ env.commitShort }}\n"
            MESSAGE+="- Parents:     ${{ env.parents }}\n"
            MESSAGE+="- Author:      ${{ env.author }}\n"
            MESSAGE+="- Date:        ${{ env.date }}\n"
            MESSAGE+="- Committer:   ${{ env.committer }}\n"
            MESSAGE+="- Message:     ${{ env.message }}\n"
          fi

          # Mesajın son bölümünü ekliyoruz.
          MESSAGE+=$'\n'
          MESSAGE+="--------------------------------------------------\n"
          MESSAGE+="**API Response**\n"
          MESSAGE+="- File version id: ${{ env.recordId }}\n"
          MESSAGE+="- You can access the shielded file from this link : https://dev.management.file-security.icredible.com/dashboard/file-management/${{ env.endpointId }}/${{ env.directoryRecordId }}"

          # GitHub Actions'ın çok satırlı komutları doğru işlemesi için
          # özel karakterleri (% -> %25, \n -> %0A) URL-encode formatına çeviriyoruz.
          MESSAGE="${MESSAGE//'%'/'%25'}"
          MESSAGE="${MESSAGE//$'\n'/'%0A'}"
          MESSAGE="${MESSAGE//$'\r'/'%0D'}"
          
          # Son olarak, formatlanmış mesajı tek bir ::notice komutuyla yazdırıyoruz.
          echo "::notice::$MESSAGE"

  # 3. İş: Geçici Önbelleği Temizle
  cleanup:
    runs-on: ubuntu-latest
    # Bu iş, önceki işlerin sonucuna bakılmaksızın her zaman çalışır.
    if: always()
    needs: [auth_and_Upload]
    # Önbelleği silebilmek için 'actions: write' izni gereklidir.
    permissions:
      actions: write
    steps:
      - name: Clean up temporary backup cache
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Cleaning up cache with key: ${{ env.BACKUP_CACHE_KEY }}"
          gh cache delete "${{ env.BACKUP_CACHE_KEY }}" --confirm || echo "Cache entry not found or already deleted."
