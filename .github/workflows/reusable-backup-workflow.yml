#.github/workflows/reusable-backup-workflow.yml

name: Reusable Backup Workflow with Cache

on:
  workflow_call:
    secrets:
      activation_code:
        description: 'Activation code for the backup service'
        required: true
      encryption_password:
        description: 'Password to encrypt the backup archive'
        required: true
        
env:
  BACKUP_CACHE_KEY: backup-cache-${{ github.run_id }}-

jobs:

  inputs_check:
    runs-on: ubuntu-latest
    steps:
      - name: Validate encryption password length
        shell: bash
        run: |
          ENC_KEY="${{ secrets.encryption_password }}"
          if [ "${#ENC_KEY}" -lt 32 ]; then
            echo "::error ::The encryption_password must be at least 32 characters long (got ${#ENC_KEY})."
            exit 1
          fi
          
  uploading_and_encryption:
    runs-on: ubuntu-latest
    needs: inputs_check
    outputs:
      encrypted_file_name: ${{ steps.encrypt_step.outputs.encrypted_file_name }}
      uncompressed_size: ${{ steps.encrypt_step.outputs.uncompressed }}
      compressed_size: ${{ steps.encrypt_step.outputs.compressed }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
  
      - name: Configure Repository for Full Mirror
        shell: bash
        run: |
          git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
          git config remote.origin.tagopt --tags
          git fetch origin --prune --tags --force
          
          git for-each-ref --format='%(refname:short)' refs/remotes/origin | grep -v HEAD | while read branch; do
              b=${branch#origin/}
              if ! git show-ref --quiet refs/heads/"$b"; then
                  git branch "$b" "$branch"
              fi
          done

      - name: Clone Repository in Mirror Mode
        shell: bash
        run: |
          git clone --mirror . repo-mirror
          cd repo-mirror
          echo "--- Mirror Branches ---"
          git branch -a
          echo "--- Mirror Tags ---"
          git tag -l
  
      - name: Install Dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y zstd jq
  
          
      - name: Encrypt Compressed Repository
        id: encrypt_step
        shell: bash
        run: |
          REPO_NAME=$(basename "${{ github.repository }}")
          ENC_FILE_NAME="$REPO_NAME.tar.zst.enc"

          tar -cf repo.tar repo-mirror
          zstd -9 repo.tar -o repo.tar.zst
          openssl enc -aes-256-cbc -salt -pbkdf2 -in repo.tar.zst -out "$ENC_FILE_NAME" -pass pass:${{ secrets.encryption_password }}

          echo "ENC_FILE_NAME=$ENC_FILE_NAME" >> $GITHUB_ENV

          echo "encrypted_file_name=$ENC_FILE_NAME" >> $GITHUB_OUTPUT
          echo "uncompressed=$(stat --printf='%s' repo.tar)" >> $GITHUB_OUTPUT
          echo "compressed=$(stat --printf='%s' "$ENC_FILE_NAME")" >> $GITHUB_OUTPUT

      - name: Save encrypted backup to cache
        id: cache
        uses: actions/cache/save@v4
        with:
          path: ${{ env.ENC_FILE_NAME }}
          key: ${{ env.BACKUP_CACHE_KEY }}
      
      - name: try again if needed
        uses: actions/cache/save@v4
        if: ${{ failure() && steps.cache.conclusion == 'failure' }}
        with:
          path: ${{ env.ENC_FILE_NAME }}
          key: ${{ env.BACKUP_CACHE_KEY }}

          
  auth_and_Upload:
    runs-on: ubuntu-latest
    needs: uploading_and_encryption
    steps:
      - name: Restore encrypted backup from cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ needs.uploading_and_encryption.outputs.encrypted_file_name }}
          key: ${{ env.BACKUP_CACHE_KEY }}
          # Bu parametre kritik öneme sahiptir: Önbellek bulunamazsa, iş başarısız olur.
          fail-on-cache-miss: true
      
      - name: Get Activation Token
        id: activation
        shell: bash
        run: |
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://dev.api.file-security.icredible.com/endpoint/activation" \
          -H "Content-Type: application/json" \
          -d '{
            "activationCode": "${{ secrets.activation_code }}",
            "uniqueId": "${{ github.repository_id }}",
            "ip": "${{ runner.ip }}",
            "operatingSystem": "Linux",
            "endpointType": "Workstation",
            "endpointName": "Github Endpoint (${{ github.repository }})"
          }')
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          JSON_BODY=$(echo "$RESPONSE" | head -n -1)
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Activation failed: $JSON_BODY"
            exit 1
          fi

          echo "token=$(echo "$JSON_BODY" | jq -r '.data.token')" >> $GITHUB_OUTPUT
          echo "endpointId=$(echo "$JSON_BODY" | jq -r '.data.endpointId')" >> $GITHUB_OUTPUT
  
      - name: Upload Backup to Shield API (with dynamic commit meta)
        id: shieldRequest
        shell: bash
        env:
          TOKEN: ${{ steps.activation.outputs.token }}
        run: |
          ENC_FILE_NAME="${{ needs.uploading_and_encryption.outputs.encrypted_file_name }}"
          UNCOMPRESSED_SIZE="${{ needs.uploading_and_encryption.outputs.uncompressed_size }}"
          COMPRESSED_SIZE="${{ needs.uploading_and_encryption.outputs.compressed_size }}"

          EVENT="${{ github.event_name }}"
          REF="${{ github.ref }}"
          ACTOR="${{ github.actor }}"
          OWNER="${{ github.repository_owner }}"
          OWNER_TYPE="${{ github.event.repository.owner.type }}"
          
          if git rev-parse --verify HEAD >/dev/null 2>&1; then
            COMMIT=$(git log -1 --pretty=format:"%H")
            SHORT=$(git log -1 --pretty=format:"%h")
            PARENTS=$(git log -1 --pretty=format:"%P")
            AUTHOR=$(git log -1 --pretty=format:"%an <%ae>")
            DATE=$(git log -1 --pretty=format:"%ad")
            COMMITTER=$(git log -1 --pretty=format:"%cn")
            MESSAGE=$(git log -1 --pretty=format:"%s%n%b")
          else
            COMMIT=""
            SHORT=""
            PARENTS=""
            AUTHOR=""
            DATE=""
            COMMITTER=""
            MESSAGE=""
          fi
          
          CURL_ARGS=(
            -F "MetaData[Event]=$EVENT"
            -F "MetaData[Ref]=$REF"
            -F "MetaData[Actor]=$ACTOR"
            -F "MetaData[Owner]=$OWNER"
            -F "MetaData[OwnerType]=$OWNER_TYPE"
          )
          [ -n "$COMMIT" ] && CURL_ARGS+=(-F "MetaData[Commit]=$COMMIT")
          [ -n "$SHORT" ] && CURL_ARGS+=(-F "MetaData[CommitShort]=$SHORT")
          [ -n "$PARENTS" ] && CURL_ARGS+=(-F "MetaData[Parents]=$PARENTS")
          [ -n "$AUTHOR" ] && CURL_ARGS+=(-F "MetaData[Author]=$AUTHOR")
          [ -n "$DATE" ] && CURL_ARGS+=(-F "MetaData[Date]=$DATE")
          [ -n "$COMMITTER" ] && CURL_ARGS+=(-F "MetaData[Committer]=$COMMITTER")
          [ -n "$MESSAGE" ] && CURL_ARGS+=(-F "MetaData[Message]=$MESSAGE")

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://dev.api.file-security.icredible.com/backup/shield" \
            -H "Authorization: Bearer $TOKEN" \
            -F "file=@$ENC_FILE_NAME" \
            -F "Size=$UNCOMPRESSED_SIZE" \
            -F "CompressedFileSize=$COMPRESSED_SIZE" \
            -F "Attributes=32" \
            -F "FileName=${{ github.repository }}" \
            -F "CompressionEngine=None" \
            -F "CompressionLevel=NoCompression" \
            -F "FullPath=/${{ github.repository }}/repo.tar.zst" \
            -F "encryptionType=None" \
            -F "RevisionType=1" \
            "${CURL_ARGS[@]}"
          )

          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          JSON_BODY=$(echo "$RESPONSE" | head -n -1)
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Upload failed: $JSON_BODY"
            exit 1
          fi

          echo "recordId=$(echo "$JSON_BODY" | jq -r '.data.recordId')" >> $GITHUB_ENV
          echo "directoryRecordId=$(echo "$JSON_BODY" | jq -r '.data.directoryRecordId')" >> $GITHUB_ENV
          
          # Özet adımı için tüm git verilerini çıktı olarak ayarlıyoruz.
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "commitShort=$SHORT" >> $GITHUB_OUTPUT
          echo "parents=$PARENTS" >> $GITHUB_OUTPUT
          echo "author=$AUTHOR" >> $GITHUB_OUTPUT
          echo "date=$DATE" >> $GITHUB_OUTPUT
          echo "committer=$COMMITTER" >> $GITHUB_OUTPUT
          echo "message=$(echo "$MESSAGE" | tr '\n' ' ')" >> $GITHUB_OUTPUT

          echo "Backup uploaded successfully."

      - name: Print Backup Summary
        if: success()
        shell: bash
        env:
          recordId: ${{ steps.shieldRequest.outputs.recordId }}
          directoryRecordId: ${{ steps.shieldRequest.outputs.directoryRecordId }}
          commit: ${{ steps.shieldRequest.outputs.commit }}
          commitShort: ${{ steps.shieldRequest.outputs.commitShort }}
          parents: ${{ steps.shieldRequest.outputs.parents }}
          author: ${{ steps.shieldRequest.outputs.author }}
          date: ${{ steps.shieldRequest.outputs.date }}
          committer: ${{ steps.shieldRequest.outputs.committer }}
          message: ${{ steps.shieldRequest.outputs.message }}
          endpointId: ${{ steps.activation.outputs.endpointId }}
        run: |
          # 1. Adım: Koşullu "Upload Metadata" bloğunu hazırla.
          # Eğer commit bilgisi yoksa bu değişken boş kalacak.
          UPLOAD_METADATA=""
          if [ -n "${{ env.commit }}" ]; then
            UPLOAD_METADATA=$(cat <<EOF
          --------------------------------------------------
          **Upload Metadata**
          - Commit:      ${{ env.commit }}
          - CommitShort: ${{ env.commitShort }}
          - Parents:     ${{ env.parents }}
          - Author:      ${{ env.author }}
          - Date:        ${{ env.date }}
          - Committer:   ${{ env.committer }}
          - Message:     ${{ env.message }}
          EOF
            )
          fi

          # 2. Adım: Ana metin şablonunu oluştur ve koşullu bloğu araya ekle.
          # Eğer UPLOAD_METADATA boş ise, bu satır hiçbir şey yazdırmaz.
          SUMMARY=$(cat <<EOF
          ✅ **Backup completed successfully!**

          --------------------------------------------------
          **Git Metadata**
          Repository: ${{ github.repository }}
          - Owner: ${{ github.repository_owner }} [${{ github.event.repository.owner.type }}]
          - Event: ${{ github.event_name }}
          - Ref:   ${{ github.ref }}
          - Actor: ${{ github.actor }}

          ${UPLOAD_METADATA}
          --------------------------------------------------
          **API Response**
          - File version id: ${{ env.recordId }}
          - You can access the shielded file from this link : https://dev.management.file-security.icredible.com/dashboard/file-management/${{ env.endpointId }}/${{ env.directoryRecordId }}
          EOF
          )

          # 3. Adım: GitHub'ın anlayacağı formata çevir ve yazdır.
          MESSAGE="${SUMMARY//'%'/'%25'}"
          MESSAGE="${MESSAGE//$'\n'/'%0A'}"
          MESSAGE="${MESSAGE//$'\r'/'%0D'}"

          echo "::notice::$MESSAGE"

  cleanup:
    runs-on: ubuntu-latest
    if: always()
    needs: [auth_and_Upload]
    permissions:
      actions: write
    steps:
      - name: Clean up temporary backup cache via REST API
        env:
          # API isteği için GITHUB_TOKEN gereklidir
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deleting cache with key: ${{ env.BACKUP_CACHE_KEY }}"
          
          # GitHub Actions Cache API'sine DELETE isteği gönder
          curl -L \
            -X DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/caches?key=${{ env.BACKUP_CACHE_KEY }}"
