#.github/workflows/reusable-backup-workflow.yml

name: Reusable Backup Workflow with Cache

on:
  workflow_call:
    inputs:
      backup_path:
        description: 'Path to the directory or file to be backed up'
        required: true
        type: string
    secrets:
      activation_code:
        description: 'Activation code for the backup service'
        required: true
      encryption_password:
        description: 'Password to encrypt the backup archive'
        required: true

# Her iş akışı çalıştırması için benzersiz bir önbellek anahtarı tanımlıyoruz.
# Bu, tüm işlerde tutarlı bir anahtar kullanılmasını sağlar ve çakışmaları önler.
env:
  BACKUP_CACHE_KEY: backup-cache-${{ github.run_id }}

jobs:
  # 1. İş: Yedeklemeyi Başlat
  initialize:
    runs-on: ubuntu-latest
    outputs:
      backup_filename: ${{ steps.generate_info.outputs.filename }}
    steps:
      - name: Generate Backup Information
        id: generate_info
        run: |
          FILENAME="backup-$(date +%Y%m%d-%H%M%S).zip"
          echo "Generated filename: $FILENAME"
          echo "filename=$FILENAME" >> "$GITHUB_OUTPUT"

  # 2. İş: Arşivle, Şifrele ve Önbelleğe Kaydet
  # Bu iş, yerel dosya işlemlerini (arşivleme ve şifreleme) birleştirir
  # ve sadece nihai sonucu (şifrelenmiş dosya) ağ üzerinden aktarır. Bu, en verimli yaklaşımdır.
  create_encrypt_and_cache:
    runs-on: ubuntu-latest
    needs: initialize
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create backup archive
        run: |
          zip -r ${{ needs.initialize.outputs.backup_filename }} ${{ inputs.backup_path }}
      
      - name: Encrypt the archive
        run: |
          echo "Encrypting ${{ needs.initialize.outputs.backup_filename }}..."
          # Gerçek şifreleme komutu (örneğin openssl) burada kullanılmalıdır.
          # openssl enc -aes-256-cbc -salt -in ${{ needs.initialize.outputs.backup_filename }} -out ${{ needs.initialize.outputs.backup_filename }}.enc -k "${{ secrets.encryption_password }}"
          mv ${{ needs.initialize.outputs.backup_filename }} ${{ needs.initialize.outputs.backup_filename }}.enc
          echo "Encryption complete."

      # Artifact yerine, şifrelenmiş dosyayı önbelleğe kaydediyoruz.
      - name: Save encrypted backup to cache
        uses: actions/cache/save@v4
        with:
          path: ${{ needs.initialize.outputs.backup_filename }}.enc
          key: ${{ env.BACKUP_CACHE_KEY }}

  # 3. İş: Önbellekten Geri Yükle ve Depolamaya Yükle
  upload:
    runs-on: ubuntu-latest
    needs: [initialize, create_encrypt_and_cache]
    steps:
      # Artifact yerine, şifrelenmiş dosyayı önbellekten geri yüklüyoruz.
      - name: Restore encrypted backup from cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ needs.initialize.outputs.backup_filename }}.enc
          key: ${{ env.BACKUP_CACHE_KEY }}
          # Bu parametre kritik öneme sahiptir: Önbellek bulunamazsa, iş başarısız olur.
          # Bu, eksik veriyle devam etmeyi önler.
          fail-on-cache-miss: true
      
      - name: Authenticate with Activation Code
        run: |
          echo "Authenticating with the provided activation code..."
          # export MY_SERVICE_TOKEN="${{ secrets.activation_code }}"
          echo "Authentication successful."

      - name: Upload to final destination
        run: |
          echo "Uploading ${{ needs.initialize.outputs.backup_filename }}.enc to the backup storage..."
          # Gerçek yükleme komutları burada yer alır.
          ls -lh ${{ needs.initialize.outputs.backup_filename }}.enc
          echo "Upload complete."

  # 4. İş: Geçici Önbelleği Temizle
  cleanup:
    runs-on: ubuntu-latest
    # Bu iş, önceki işler başarısız olsa bile her zaman çalışır.
    if: always()
    needs: [upload]
    # Önbelleği silebilmek için 'actions: write' izni gereklidir.
    permissions:
      actions: write
    steps:
      - name: Clean up temporary backup cache
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Cleaning up cache with key: ${{ env.BACKUP_CACHE_KEY }}"
          gh cache delete "${{ env.BACKUP_CACHE_KEY }}" --confirm |

| echo "Cache entry not found or already deleted."
