name: 'MyApp Backup Action'
description: 'Repository mirror backup, ZSTD compression, and API upload. Optionally uses org ID.'
branding:
  icon: 'archive'
  color: 'blue'

inputs:
  activation_code:
    description: 'Activation code for API'
    required: true
  encryption_key:
    description: 'Secret key for encrypting the backup'
    required: true
  use_org_id:
    description: 'Set to true to use organization ID instead of repository ID'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Clone Repository in Mirror Mode
      shell: bash
      run: git clone --mirror . repo-mirror

    - name: Install Dependencies
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y zstd jq
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
        sudo apt-get update
        sudo apt-get install -y gh

    - name: Export Repository Metadata
      shell: bash
      run: |
        mkdir -p repo-metadata

        # Repo basic info
        gh repo view --json name,description,createdAt,updatedAt,defaultBranchRef,mergeCommitAllowed,rebaseMergeAllowed,squashMergeAllowed > repo-metadata/repo-info.json

        # Issues
        gh issue list --state all --json number,title,state,body,createdAt,updatedAt,closedAt,labels,assignees,comments > repo-metadata/issues.json

        # Branches => sadece nodes array'i sakla!
        gh api graphql -f query='
          {
            repository(owner: "${{ github.repository_owner }}", name: "${{ github.event.repository.name }}") {
              refs(refPrefix: "refs/heads/", first: 100) {
                nodes {
                  name
                  target {
                    oid
                  }
                }
              }
            }
          }' | jq '.data.repository.refs' > repo-metadata/branches.json

        # Pull Requests
        gh pr list --state all --json number,title,state,body,createdAt,closedAt,mergedAt,baseRefName,headRefName,labels > repo-metadata/pull_requests.json

         # BACKUP ALL PR COMMENTS (issue comments + review comments)
        for pr_number in $(gh pr list --json number --jq '.[].number'); do
          echo "Backing up issue comments for PR #$pr_number"
          gh api repos/${{ github.repository_owner }}/${{ github.event.repository.name }}/issues/$pr_number/comments > "repo-metadata/pr_issue_comments_$pr_number.json"

          echo "Backing up review comments for PR #$pr_number"
          gh api repos/${{ github.repository_owner }}/${{ github.event.repository.name }}/pulls/$pr_number/comments > "repo-metadata/pr_review_comments_$pr_number.json"
        done
        
        # Labels & Milestones
        gh api graphql -f query='
          {
            repository(owner: "${{ github.repository_owner }}", name: "${{ github.event.repository.name }}") {
              labels(first: 100) {
                nodes {
                  name
                  color
                  description
                }
              }
              milestones(first: 100) {
                nodes {
                  title
                  state
                  description
                  dueOn
                }
              }
            }
          }' | jq . > repo-metadata/labels_milestones.json
      env:
        GH_TOKEN: ${{ github.token }}
        
    - name: Install ZSTD
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y zstd

    - name: Encrypt Compressed Repository
      shell: bash
      run: |
        REPO_NAME=$(basename "${{ github.repository }}")
        ENC_FILE_NAME="$REPO_NAME.tar.zst.enc"

        tar -cf repo.tar repo-mirror repo-metadata
        zstd -9 repo.tar -o repo.tar.zst
        openssl enc -aes-256-cbc -salt -pbkdf2 -in repo.tar.zst -out "$ENC_FILE_NAME" -pass pass:${{ inputs.encryption_key }}

        echo "ENC_FILE_NAME=$ENC_FILE_NAME" >> $GITHUB_ENV
        echo "UNCOMPRESSED_SIZE=$(stat --printf='%s' repo.tar)" >> $GITHUB_ENV
        echo "COMPRESSED_SIZE=$(stat --printf='%s' repo.tar.zst.enc)" >> $GITHUB_ENV

    - name: Get Organization ID (if requested)
      if: inputs.use_org_id == 'true'
      shell: bash
      run: |
        ORG="${{ github.repository_owner }}"
        ORG_JSON=$(curl -s -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }}" \
          "https://api.github.com/orgs/$ORG")
        ORG_ID=$(echo "$ORG_JSON" | jq -r '.id')
        echo "UNIQUE_ID=$ORG_ID" >> $GITHUB_ENV

    - name: Set Repository ID (default)
      if: inputs.use_org_id != 'true'
      shell: bash
      run: echo "UNIQUE_ID=${{ github.repository_id }}" >> $GITHUB_ENV

    - name: Get Activation Token
      shell: bash
      run: |
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST " https://dev.api.file-security.icredible.com/endpoint/activation " \
        -H "Content-Type: application/json" \
        -d '{
          "activationCode": "${{ inputs.activation_code }}",
          "uniqueId": "'$UNIQUE_ID'",
          "ip": "${{ runner.ip }}",
          "operatingSystem": "Linux",
          "endpointType": "Workstation",
          "endpointName": "Github Endpoint (${{ github.repository }})"
        }')
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        JSON_BODY=$(echo "$RESPONSE" | head -n -1)
        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo "Activation failed: $JSON_BODY"
          exit 1
        fi
        TOKEN=$(echo "$JSON_BODY" | jq -r '.data.token')
        echo "TOKEN=$TOKEN" >> $GITHUB_ENV

    - name: Upload Backup to Shield API (with dynamic commit meta)
      shell: bash
      run: |
        EVENT="${{ github.event_name }}"
        REF="${{ github.ref }}"
        ACTOR="${{ github.actor }}"
        
        if git rev-parse --verify HEAD >/dev/null 2>&1; then
          COMMIT=$(git log -1 --pretty=format:"%H")
          SHORT=$(git log -1 --pretty=format:"%h")
          PARENTS=$(git log -1 --pretty=format:"%P")
          AUTHOR=$(git log -1 --pretty=format:"%an <%ae>")
          DATE=$(git log -1 --pretty=format:"%ad")
          COMMITTER=$(git log -1 --pretty=format:"%cn")
          MESSAGE=$(git log -1 --pretty=format:"%s%n%b")
        else
          COMMIT=""
          SHORT=""
          PARENTS=""
          AUTHOR=""
          DATE=""
          COMMITTER=""
          MESSAGE=""
        fi

        CURL_ARGS=(
          -F "MetaData[Event]=$EVENT"
          -F "MetaData[Ref]=$REF"
          -F "MetaData[Actor]=$ACTOR"
        )
        [ -n "$COMMIT" ] && CURL_ARGS+=(-F "MetaData[Commit]=$COMMIT")
        [ -n "$SHORT" ] && CURL_ARGS+=(-F "MetaData[CommitShort]=$SHORT")
        [ -n "$PARENTS" ] && CURL_ARGS+=(-F "MetaData[Parents]=$PARENTS")
        [ -n "$AUTHOR" ] && CURL_ARGS+=(-F "MetaData[Author]=$AUTHOR")
        [ -n "$DATE" ] && CURL_ARGS+=(-F "MetaData[Date]=$DATE")
        [ -n "$COMMITTER" ] && CURL_ARGS+=(-F "MetaData[Committer]=$COMMITTER")
        [ -n "$MESSAGE" ] && CURL_ARGS+=(-F "MetaData[Message]=$MESSAGE")

        echo "CURL_ARGS content:"
        printf "'%s'\n" "${CURL_ARGS[@]}"

        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          "https://dev.api.file-security.icredible.com/backup/shield" \
          -H "Authorization: Bearer $TOKEN" \
          -F "file=@$ENC_FILE_NAME" \
          -F "Size=$UNCOMPRESSED_SIZE" \
          -F "CompressedFileSize=$COMPRESSED_SIZE" \
          -F "Attributes=32" \
          -F "FileName=${{ github.repository }}" \
          -F "CompressionEngine=None" \
          -F "CompressionLevel=NoCompression" \
          -F "FullPath=/github/${{ github.repository }}/repo.tar.zst" \
          -F "encryptionType=None" \
          -F "RevisionType=1" \
          "${CURL_ARGS[@]}"
        )
        
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        JSON_BODY=$(echo "$RESPONSE" | head -n -1)
        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo "Upload failed: $JSON_BODY"
          exit 1
        fi
        
        echo "$JSON_BODY"
        echo "Backup uploaded successfully."

